# Техническая информация о проекте

В этом разделе будет описана структура файлов проекта: что, где и как лежит.

Итак, открыв проект в редакторе Unity (или разглядывая его любым другим удобным способом), вы увидете следующее:
- **Assets / _Project** - непосредственно файлы проекта. Почти все, что сделано в рамках проекта, лежит здесь.
- **Assets / Plugins / ZerglingUnityPlugins** - набор моих решений для некоторых базовых задач, которые были сделаны в виде подключаемых Package-ей.
- **Assets / Resources** - там лежат единичные файлы, необходимые для фреймворков и/или других ассетов. Сейчас там лежит только ProjectContext для Zenject-а и конфиг настроек для Dotween.
- **Assets / все остальное** - third-party ассеты и плагины, взятые из Unity Asset Store и/или других площадок.

Теперь давайте поглубже посмотрим некотроые папки.

Assets / _Project / Scripts / ... :
- **Project** - функционал, общий для всего проекта, может использоваться во всех сценах.
- **StartScene** - функционал стартовой сцены проекта (сплеш скрин)
- **MainMenu** - функционал сцены главного меню проекта
- **GameScene** - функционал игровой сцены проекта. Под игровой сценой подразумевается сцена любого из уровней, они работают по одинаковой логике.

Такая структура с разделением на папки сцен используется во всех ключевых папках проекта. 

Точки входа:
- **ProjectInstaller** - базовый Zenject инсталлер проекта, в нем биндится функционал уровня Project, который может использоваться во всех остальных сценах
- **StartSceneInstaller** - инсталлер стартовой сцены
- **StartSceneController** - контроллер стартовой сцены
- **ScartSceneServiceIniter** - инициализатор сервисов стартовой сцены
- **MainSceenInstaller** - инсталлер сцены главного меню
- **MainSceneController** - контроллер сцены главного меню
- **MainSceneServiceIniter** - инициализатор сервисов сцены главного меню
- **GameSceneInstaller** - инсталлер игровой сцены
- **GameSceneController** - контроллер игровой сцены
- **GameSceneServiceIniter** - инициализатор сервисов игровой сцены

Стартовая сцена и сцена главного меню довольно скудны на функционал, поэтому основное внимание стоит уделить **игровой сцене**, **общей папке проекта** и **плагинам** (плагинам, желательно, в последнюю очередь, там небольшой бардак :)).

Ключевые пункты по технической реализации проекта:
- Используется фрейворк **Zenject**, реализующий инъекцию зависимостей. От фреймворка используются DIContainer, фабрики и объектные пулы. Сигналы я перестал использовать еще в 2017 году из-за их не очень удачной реализации (при отправке каждый сигнал вызывал аллокации на 2МБ!), до сих пор не дошли руки посмотреть их снова для возможной реабилитации.
- Преобладают микросервисы (насколько это возможно). Предполагается, что над несколькими микросервисами одной фичи/механики будет общий **фасад**, через который можно будет обращаться к фиче/механике целиком, а он там уже сам будет вызывать отдельные микросервисы.

"Сильные стороны" проекта на мой взгляд:
- Стуркутра проекта в целом. Программисты имеют очень много контроля над порядком выполнения функционала, каждая фича делается с возможностью масштабирования (насколько это возможно), чтобы выдержать любые приколы геймдизайнера.
- Реализация существ _(Creatures)_ и их иерархия классов. Возможно решение довольно очевидное, но мне почему-то очень нравится, как они сейчас выглядят.
- Реализация интерактивных объектов _(InteractableObjects)_. Реализация еще не закончена (из интерактивных объектов есть только дверь), но идея примерно такая же, как и с существами: есть базовый класс интерактивного объекта, а от него уже будут наследники для реазилации конкретных интерактивных объектов с их приколами.
- Инпут. Ну, тут задел на кроссплатформу. Мы на старте проекта ее не сильно рассматривали, но я решил подстелить соломку на всякий случай.

"Слабые стороны" проекта на мой взгляд:
- В проекте присутствует антипаттерн EventBus. Он присутствует намеренно и нужен исключительно для связи кор логики с УИ.
- Стейт машина для существ с несколькими активным состояниями. В целом странное решение и извращение над стейт машиной, которое может породить огромное количество багов. Идея возникла из поведения существ в World of Warcraft. Они там могут одновременно двигаться и атаковать, а от состояния "в бою" зависят анимации айдла. Возможно стоило это распилить на несколько стейт машин с одним активным состоянием, но пока решил сделать вот так.
- Уровни как префабы. Довольно глупое решение, сделанное второпях и разбившееся о простой вопрос "а как мы будем запекать свет в префабах". После этого было принято решение переписать систему на набор отдельных сцех, а внутри каждой будет префаб с базовым функционалом. Таким образом базовый функционал сцены будет редактироваться для всех сцен сразу и свет запекаться будет для всей сцены.
- Мой воспаленный перфекционизм и подход сделать так, чтобы предусмотреть максимальное количество подводных камней. Прямое противоречие принципу YAGNI, но я как-то очень сильно обжегся об это на основной работе причем даже не по своей вине, поэтому теперь оно как-то вот так :)
